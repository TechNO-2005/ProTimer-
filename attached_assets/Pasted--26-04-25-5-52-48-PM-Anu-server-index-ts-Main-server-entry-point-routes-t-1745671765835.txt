[26/04/25, 5:52:48 PM] Anu: server/
├── index.ts              # Main server entry point
├── routes.ts             # API routes definition
├── auth.ts               # Authentication logic
├── storage.ts            # Database/storage interface
└── vite.ts               # Vite integration for development
 [26/04/25, 5:52:49 PM] Anu: import { useEffect } from "react";
import { Switch, Route } from "wouter";
import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";
import { Toaster } from "@/components/ui/toaster";
import { AuthProvider } from "@/hooks/use-auth";
import LandingPage from "@/pages/landing-page";
import AuthPage from "@/pages/auth-page";
import Dashboard from "@/pages/Dashboard";
import Schedule from "@/pages/Schedule";
import Tasks from "@/pages/Tasks";
import Priorities from "@/pages/Priorities";
import Habits from "@/pages/Habits";
import Flashcards from "@/pages/Flashcards";
import SmartMeetings from "@/pages/SmartMeetings";
import CalendarSync from "@/pages/CalendarSync";
import NotFound from "@/pages/not-found";
import { ProtectedRoute } from "@/lib/protected-route";
import "./index.css";

// Router component with protected routes
function Router() {
  return (
    <Switch>
      <Route path="/" component={LandingPage} />
      <Route path="/auth" component={AuthPage} />
      <ProtectedRoute path="/home" component={Dashboard} />
      <ProtectedRoute path="/schedule" component={Schedule} />
      <ProtectedRoute path="/tasks" component={Tasks} />
      <ProtectedRoute path="/priorities" component={Priorities} />
      <ProtectedRoute path="/habits" component={Habits} />
      <ProtectedRoute path="/flashcards" component={Flashcards} />
      <ProtectedRoute path="/smart-meetings" component={SmartMeetings} />
      <ProtectedRoute path="/calendar-sync" component={CalendarSync} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-[#1a1a1a] to-black text-white">
      <div className="max-w-[1600px] mx-auto">
        <QueryClientProvider client={queryClient}>
          <AuthProvider>
            <Router />
            <Toaster />
          </AuthProvider>
        </QueryClientProvider>
      </div>
    </div>
  );
}

export default App;
 [26/04/25, 5:52:50 PM] Anu: import { useLocation, Link } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { 
  Home, 
  Calendar, 
  BarChart2, 
  LayoutGrid, 
  Clock, 
  BookOpen, 
  Users, 
  Globe, 
  ChevronLeft,
  ChevronRight,
  LogOut
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { useState } from "react";

interface SidebarProps {
  visible: boolean;
  onToggle: () => void;
}

const Sidebar = ({ visible, onToggle }: SidebarProps) => {
  const [location] = useLocation();
  const { user, logoutMutation } = useAuth();
  const isGuestMode = localStorage.getItem("guestMode") === "true";
  
  // For mobile, we need to be able to close the sidebar
  const [isMobileExpanded, setIsMobileExpanded] = useState(false);
  
  const handleLogout = () => {
    if (isGuestMode) {
      // Remove guest mode and redirect to landing page
      localStorage.removeItem("guestMode");
      window.location.href = "/";
    } else {
      // Regular logout for authenticated users
      logoutMutation.mutate();
      window.location.href = "/";
    }
  };
  
  const navLinks = [
    { path: "/home", label: "Home", icon: <Home className="h-5 w-5" /> },
    { path: "/schedule", label: "Schedule", icon: <Calendar className="h-5 w-5" /> },
    { path: "/priorities", label: "Priorities", icon: <BarChart2 className="h-5 w-5" /> },
    { path: "/tasks", label: "Tasks", icon: <LayoutGrid className="h-5 w-5" /> },
    { path: "/habits", label: "Habits", icon: <Clock className="h-5 w-5" /> },
    { path: "/flashcards", label: "Flashcards", icon: <BookOpen className="h-5 w-5" /> },
    { path: "/smart-meetings", label: "Smart Meetings", icon: <Users className="h-5 w-5" /> },
    { path: "/calendar-sync", label: "Calendar Sync", icon: <Globe className="h-5 w-5" /> },
  ];

  // Mobile sidebar toggle
  const toggleMobileSidebar = () => {
    setIsMobileExpanded(!isMobileExpanded);
  };

  return (
    <>
      {/* Desktop Sidebar */}
      <div 
        className={fixed z-50 left-0 top-0 bottom-0 w-[355px] bg-gradient-to-b from-[#388282] via-[#275050] to-[#234848] transition-all duration-300 hidden md:block ${visible ? 'translate-x-0' : '-translate-x-full'}}
      >
        <div className="px-8 pt-8 pb-4 flex flex-col h-full">
          <div className="flex justify-between items-center">
            <h1 className="font-['Jaro'] text-4xl text-white mb-12">ProTimer</h1>
            <Button
              variant="ghost"
              size="icon"
              onClick={onToggle}
              className="text-white hover:bg-white/10"
            >
              {visible ? <ChevronLeft /> : <ChevronRight />}
            </Button>
          </div>
          
          <nav className="space-y-4 flex-1">
            {navLinks.map((link) => (
              <Link 
                key={link.path} 
                href={link.path}
                className={`flex items-center gap-3 text-white text-xl py-2 px-2 rounded-md transition-colors ${
                  location === link.path 
                    ? 'bg-[#312727] shadow-[0px_0px_4px_4px_rgba(224.66,234.09,232.68,0.45)]' 
                    : 'hover:text-[#00FFFF]'
                }`}
              >
                {link.icon}
                <span>{link.label}</span>
              </Link>
            ))}
          </nav>

          <div className="mt-auto pt-4 border-t border-white/20">
            <div className="flex items-center justify-between mb-4">
              <div>
                <p className="text-white text-lg">{isGuestMode ? "Guest User" : user?.username}</p>
                <p className="text-gray-300 text-sm">{isGuestMode ? "Local data only" : "Signed In"}</p>
              </div>
              <Button
                variant="ghost"
                size="sm"
                onClick={handleLogout}
                className="text-white hover:bg-white/10"
              >
                <LogOut className="h-5 w-5 mr-2" />
                {isGuestMode ? "Exit Guest" : "Logout"}
              </Button>
            </div>
          </div>
        </div>
      </div>

      {/* Toggle Button for collapsed sidebar (Desktop) */}
      {!visible && (
        <Button
          variant="ghost"
          size="icon"
          onClick={onToggle}
          className="fixed left-4 top-4 z-50 bg-gray-800/60 text-white hover:bg-gray-700 hover:text-[#00FFFF] transition-all shadow-md hidden md:flex"
          aria-label="Open sidebar"
        >
          <ChevronRight className="h-5 w-5" />
        </Button>
      )}

      {/* Mobile Sidebar */}
      <div className="md:hidden">
        {/* Mobile sidebar toggle button (visible when sidebar is closed) */}
        {!isMobileExpanded && (
          <button 
            onClick={toggleMobileSidebar}
            className="fixed top-4 left-4 z-50 bg-[#388282] p-2 rounded-full text-white shadow-lg"
          >
            <ChevronRight className="h-6 w-6" />
          </button>
        )}

        {/* Mobile sidebar */}
        <div 
          className={`fixed inset-0 z-50 bg-black/80 backdrop-blur-sm transition-all duration-300 ${
            isMobileExpanded ? 'opacity-100' : 'opacity-0 pointer-events-none'
          }`}
          onClick={toggleMobileSidebar}
        >
          <div 
            className={`fixed left-0 top-0 bottom-0 w-[80%] max-w-[300px] bg-gradient-to-b from-[#388282] via-[#275050] to-[#234848] transition-all duration-300 ${
              isMobileExpanded ? 'translate-x-0' : '-translate-x-full'
            }`}
            onClick={(e) => e.stopPropagation()}
          >
            <div className="px-6 pt-6 pb-4 flex flex-col h-full">
              <div className="flex justify-between items-center mb-8">
                <h1 className="font-['Jaro'] text-3xl text-white">ProTimer</h1>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={toggleMobileSidebar}
                  className="text-white hover:bg-white/10"
                >
                  <ChevronLeft />
                </Button>
              </div>
              
              <nav className="space-y-3 flex-1">
                {navLinks.map((link) => (
                  <Link 
                    key={link.path} 
                    href={link.path}
                    className={`flex items-center gap-3 text-white text-base py-2 px-2 rounded-md transition-colors ${
                      location === link.path 
                        ? 'bg-[#312727] shadow-[0px_0px_4px_4px_rgba(224.66,234.09,232.68,0.45)]' 
                        : 'hover:text-[#00FFFF]'
                    }`}
                    onClick={toggleMobileSidebar}
                  >
                    {link.icon}
                    <span>{link.label}</span>
                  </Link>
                ))}
              </nav>

              <div className="mt-auto pt-4 border-t border-white/20">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-white">{isGuestMode ? "Guest User" : user?.username}</p>
                    <p className="text-gray-300 text-xs">{isGuestMode ? "Local data only" : "Signed In"}</p>
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={handleLogout}
                    className="text-white hover:bg-white/10"
                  >
                    <LogOut className="h-4 w-4 mr-1" />
                    {isGuestMode ? "Exit" : "Logout"}
                  </Button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

export default Sidebar;
 [26/04/25, 5:52:50 PM] Anu: import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Task } from "@shared/schema";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Trash2 } from "lucide-react";
import { saveGuestTask, updateGuestTask, deleteGuestTask } from "@/lib/guestStorage";
import { saveGuestHabit } from "@/lib/guestHabits";

// Define a schema for the task form validation
const taskSchema = z.object({
  id: z.string().optional(),
  name: z.string().min(1, "Task name is required"),
  date: z.string().min(1, "Date is required"),
  startTime: z.string().min(1, "Start time is required"),
  endTime: z.string().min(1, "End time is required"),
  priority: z.enum(["high", "medium", "low"]),
  completed: z.boolean().default(false),
  isHabit: z.boolean().default(false),
});

type TaskFormValues = z.infer<typeof taskSchema>;

interface TaskModalProps {
  isOpen: boolean;
  onClose: () => void;
  task: Task | null;
  selectedSlot: { date: string; startTime: string; endTime: string } | null;
  onTaskSaved: () => void;
}

const TaskModal = ({ isOpen, onClose, task, selectedSlot, onTaskSaved }: TaskModalProps) => {
  const { toast } = useToast();
  const [isDeleting, setIsDeleting] = useState(false);
  const [makeHabit, setMakeHabit] = useState(false);
  
  // Check if in guest mode
  const isGuestMode = localStorage.getItem("guestMode") === "true";
  
  // Initialize the form with default values or task values if editing
  const form = useForm<TaskFormValues>({
    resolver: zodResolver(taskSchema),
    defaultValues: {
      id: task?.id || '',
      name: task?.name || '',
      date: task?.date || selectedSlot?.date || new Date().toISOString().split('T')[0],
      startTime: task?.startTime || selectedSlot?.startTime || '09:00',
      endTime: task?.endTime || selectedSlot?.endTime || '10:00',
      priority: task?.priority || 'medium',
      completed: task?.completed || false,
      isHabit: false,
    },
  });

  useEffect(() => {
    if (isOpen) {
      // Reset form when modal opens
      form.reset({
        id: task?.id || '',
        name: task?.name || '',
        date: task?.date || selectedSlot?.date || new Date().toISOString().split('T')[0],
        startTime: task?.startTime || selectedSlot?.startTime || '09:00',
        endTime: task?.endTime || selectedSlot?.endTime || '10:00',
        priority: task?.priority || 'medium',
        completed: task?.completed || false,
        isHabit: false,
      });
      setMakeHabit(false);
    }
  }, [isOpen, task, selectedSlot, form]);

  const handleSubmit = async (data: TaskFormValues) => {
    try {
      if (isGuestMode) {
        // Handle task in guest mode (local storage)
        if (task?.id) {
          // Update existing task
          updateGuestTask(task.id, data);
          toast({
            title: "Success",
            description: "Task updated successfully (Guest Mode)",
          });
        } else {
          // Create new task
          saveGuestTask(data);
          
          // If makeHabit is true, also save as a habit
          if (makeHabit) {
            const habit = {
              id: crypto.randomUUID(),
              name: data.name,
              frequency: "daily",
              startDate: new Date().toISOString().split('T')[0],
              completed: false,
              timeOfDay: data.startTime,
              streak: 0,
              priority: data.priority,
            };
            saveGuestHabit(habit);
            toast({
              title: "Success",
              description: "Task and habit created successfully (Guest Mode)",
            });
          } else {
            toast({
              title: "Success",
              description: "Task created successfully (Guest Mode)",
            });
          }
        }
        
        onTaskSaved();
      } else {
        // Handle task on the server
        if (task?.id) {
          // Update existing task
          await apiRequest("PATCH", /api/tasks/${task.id}, data);
          toast({
            title: "Success",
            description: "Task updated successfully",
          });
        } else {
          // Create new task
          await apiRequest("POST", "/api/tasks", data);
          
          // If makeHabit is true, also create a habit
          if (makeHabit) {
            const habit = {
              name: data.name,
              frequency: "daily",
              startDate: new Date().toISOString().split('T')[0],
              completed: false,
              timeOfDay: data.startTime,
              streak: 0,
              priority: data.priority,
            };
            
            // Create habit on the server
            await apiRequest("POST", "/api/habits", habit);
            
            toast({
              title: "Success",
              description: "Task and habit created successfully",
            });
            
            // Refresh both tasks and habits
            queryClient.invalidateQueries({ queryKey: ["/api/tasks"] });
            queryClient.invalidateQueries({ queryKey: ["/api/habits"] });
          } else {
            toast({
              title: "Success",
              description: "Task created successfully",
            });
            
            // Refresh just tasks
            queryClient.invalidateQueries({ queryKey: ["/api/tasks"] });
          }
        }
        
        onTaskSaved();
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to save task",
        variant: "destructive",
      });
    }
  };

  const handleDelete = async () => {
    if (!task?.id) return;
    
    setIsDeleting(true);
    
    try {
      if (isGuestMode) {
        // Delete task in guest mode
        deleteGuestTask(task.id);
        toast({
          title: "Success",
          description: "Task deleted successfully (Guest Mode)",
        });
        onTaskSaved();
      } else {
        // Delete task on server
        await apiRequest("DELETE", /api/tasks/${task.id});
        toast({
          title: "Success",
          description: "Task deleted successfully",
        });
        queryClient.invalidateQueries({ queryKey: ["/api/tasks"] });
        onTaskSaved();
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to delete task",
        variant: "destructive",
      });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="bg-gray-900 border-gray-800 text-white">
        <DialogHeader>
          <DialogTitle className="text-white text-xl">
            {task ? "Edit Task" : "Create New Task"}
          </DialogTitle>
        </DialogHeader>
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="text-[#00FFFF]">Task Name</FormLabel>
                  <FormControl>
                    <Input 
                      placeholder="Enter task name" 
                      {...field} 
                      className="bg-gray-800 border-gray-700 text-white"
                    />
                  </FormControl>
                  <FormMessage className="text-red-400" />
                </FormItem>
              )}
            />
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="date"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-[#00FFFF]">Date</FormLabel>
                    <FormControl>
                      <Input 
                        type="date" 
                        {...field} 
                        className="bg-gray-800 border-gray-700 text-white"
                      />
                    </FormControl>
                    <FormMessage className="text-red-400" />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="priority"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-[#00FFFF]">Priority</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                      value={field.value}
                    >
                      <FormControl>
                        <SelectTrigger className="bg-gray-800 border-gray-700 text-white">
                          <SelectValue placeholder="Select priority" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="bg-gray-800 border-gray-700 text-white">
                        <SelectItem value="high">High</SelectItem>
                        <SelectItem value="medium">Medium</SelectItem>
                        <SelectItem value="low">Low</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage className="text-red-400" />
                  </FormItem>
                )}
              />
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="startTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-[#00FFFF]">Start Time</FormLabel>
                    <FormControl>
                      <Input 
                        type="time" 
                        {...field} 
                        className="bg-gray-800 border-gray-700 text-white"
                      />
                    </FormControl>
                    <FormMessage className="text-red-400" />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="endTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="text-[#00FFFF]">End Time</FormLabel>
                    <FormControl>
                      <Input 
                        type="time" 
                        {...field} 
                        className="bg-gray-800 border-gray-700 text-white"
                      />
                    </FormControl>
                    <FormMessage className="text-red-400" />
                  </FormItem>
                )}
              />
            </div>
            
            {/* Only show the "Make it a habit" option for new tasks, not when editing */}
            {!task && (
              <div className="flex items-center space-x-2">
                <Checkbox 
                  id="make-habit" 
                  checked={makeHabit}
                  onCheckedChange={(checked) => {
                    setMakeHabit(checked as boolean);
                  }}
                  className="data-[state=checked]:bg-[#00FFFF] data-[state=checked]:text-black"
                />
                <div className="grid gap-1.5 leading-none">
                  <label
                    htmlFor="make-habit"
                    className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 text-white"
                  >
                    Make it a habit
                  </label>
                  <p className="text-sm text-gray-400">
                    This will also add the task to your habits list
                  </p>
                </div>
              </div>
            )}
            
            <DialogFooter className="flex justify-between items-center gap-4 pt-4">
              {task && (
                <Button
                  type="button"
                  variant="destructive"
                  onClick={handleDelete}
                  disabled={isDeleting}
                  className="mr-auto"
                >
                  <Trash2 className="h-4 w-4 mr-2" />
                  {isDeleting ? "Deleting..." : "Delete"}
                </Button>
              )}
              <div className="flex gap-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={onClose}
                  className="bg-transparent text-white border-gray-600 hover:bg-gray-800"
                >
                  Cancel
                </Button>
                <Button
                  type="submit"
                  variant="default"
                  className="bg-[#00FFFF] text-black hover:bg-[#00FFFF]/80"
                >
                  {task ? "Update" : "Create"}
                </Button>
              </div>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};

export default TaskModal;
 [26/04/25, 5:52:54 PM] Anu: import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { Task } from "@shared/schema";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight, Calendar as CalendarIcon, Clock, Plus, Home } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { add, format, startOfWeek, endOfWeek, eachDayOfInterval, isSameDay, parseISO } from "date-fns";
import TaskModal from "@/components/TaskModal";
import { getGuestTasks, updateGuestTask } from "@/lib/guestStorage";
import { Link } from "wouter";
import FloatingActionButton from "@/components/FloatingActionButton";
import { 
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator 
} from "@/components/ui/breadcrumb";

// Implementation details as shown earlier...

const Schedule = () => {
  // State and handlers as shown earlier...

  return (
    <div className="p-8">
      {/* Breadcrumbs navigation */}
      <div className="mb-6">
        <Breadcrumb>
          <BreadcrumbList>
            <BreadcrumbItem>
              <BreadcrumbLink asChild>
                <Link href="/home">
                  <Home className="h-4 w-4 mr-1" />
                  Dashboard
                </Link>
              </BreadcrumbLink>
            </BreadcrumbItem>
            <BreadcrumbSeparator />
            <BreadcrumbItem>
              <BreadcrumbPage>Schedule</BreadcrumbPage>
            </BreadcrumbItem>
          </BreadcrumbList>
        </Breadcrumb>
      </div>
      
      <header className="mb-8">
        <h1 className="text-5xl font-bold text-white">Planner</h1>
        <p className="text-gray-400 mt-2">Manage your schedule and organize your time</p>
      </header>
      
      {/* Display guest mode indicator if applicable */}
      <GuestModeIndicator />
      
      <div className="flex flex-col md:flex-row gap-6 mb-8">
        <div className="w-full">
          {/* Calendar header with navigation */}
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-3xl font-bold text-white">
              {format(weekDays[0] || new Date(), 'MMMM yyyy')}
            </h2>
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="icon"
                onClick={() => navigateWeek('prev')}
                className="bg-gray-800/50 text-white border-gray-700 hover:bg-gray-700/50"
              >
                <ChevronLeft className="h-5 w-5" />
              </Button>
              <Button
                variant="outline"
                size="icon"
                onClick={() => navigateWeek('next')}
                className="bg-gray-800/50 text-white border-gray-700 hover:bg-gray-700/50"
              >
                <ChevronRight className="h-5 w-5" />
              </Button>
            </div>
          </div>
          
          {/* Weekly Calendar Grid */}
          {/* Calendar implementation as shown earlier... */}
        </div>
      </div>
      
      {/* Floating action button for adding tasks */}
      <FloatingActionButton 
        onClick={() => {
          setSelectedSlot({
            date: format(new Date(), 'yyyy-MM-dd'),
            startTime: format(new Date(), 'HH:00'),
            endTime: format(add(new Date(), { hours: 1 }), 'HH:00')
          });
          setEditingTask(null);
          setIsTaskModalOpen(true);
        }} 
      />
      
      {/* Task Modal for creating/editing tasks */}
      {isTaskModalOpen && (
        <TaskModal
          isOpen={isTaskModalOpen}
          onClose={handleCloseModal}
          selectedSlot={selectedSlot}
          task={editingTask}
          onTaskSaved={handleTaskSaved}
        />
      )}
    </div>
  );
};

export default Schedule;
 [26/04/25, 5:52:55 PM] Anu: import { createContext, ReactNode, useContext } from "react";
import {
  useQuery,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { insertUserSchema, User as SelectUser, InsertUser } from "@shared/schema";
import { getQueryFn, apiRequest, queryClient } from "../lib/queryClient";
import { useToast } from "@/hooks/use-toast";

type AuthContextType = {
  user: SelectUser | null;
  isLoading: boolean;
  error: Error | null;
  loginMutation: UseMutationResult<SelectUser, Error, LoginData>;
  logoutMutation: UseMutationResult<void, Error, void>;
  registerMutation: UseMutationResult<SelectUser, Error, InsertUser>;
};

type LoginData = Pick<InsertUser, "username" | "password">;

export const AuthContext = createContext<AuthContextType | null>(null);
export function AuthProvider({ children }: { children: ReactNode }) {
  const { toast } = useToast();
  const {
    data: user,
    error,
    isLoading,
  } = useQuery<SelectUser | undefined, Error>({
    queryKey: ["/api/user"],
    queryFn: getQueryFn({ on401: "returnNull" }),
  });

  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginData) => {
      const res = await apiRequest("POST", "/api/login", credentials);
      return await res.json();
    },
    onSuccess: (user: SelectUser) => {
      queryClient.setQueryData(["/api/user"], user);
    },
    onError: (error: Error) => {
      toast({
        title: "Login failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const registerMutation = useMutation({
    mutationFn: async (credentials: InsertUser) => {
      const res = await apiRequest("POST", "/api/register", credentials);
      return await res.json();
    },
    onSuccess: (user: SelectUser) => {
      queryClient.setQueryData(["/api/user"], user);
    },
    onError: (error: Error) => {
      toast({
        title: "Registration failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const logoutMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", "/api/logout");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/user"], null);
    },
    onError: (error: Error) => {
      toast({
        title: "Logout failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return (
    <AuthContext.Provider
      value={{
        user: user ?? null,
        isLoading,
        error,
        loginMutation,
        logoutMutation,
        registerMutation,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
 [26/04/25, 5:52:56 PM] Anu: import { Task } from "@shared/schema";

// Get all tasks from localStorage
export const getGuestTasks = (): Task[] => {
  const tasksJson = localStorage.getItem('guestTasks');
  if (!tasksJson) return [];
  
  try {
    return JSON.parse(tasksJson);
  } catch (error) {
    console.error('Error parsing guest tasks from localStorage', error);
    return [];
  }
};

// Save a new task to localStorage
export const saveGuestTask = (task: Omit<Task, 'id'> & { id?: string }): Task => {
  const tasks = getGuestTasks();
  
  // Generate a unique ID if one is not provided
  const newTask: Task = {
    ...task,
    id: task.id || crypto.randomUUID(),
  };
  
  tasks.push(newTask);
  localStorage.setItem('guestTasks', JSON.stringify(tasks));
  
  return newTask;
};

// Update a task in localStorage
export const updateGuestTask = (id: string, updatedFields: Partial<Task>): Task | null => {
  const tasks = getGuestTasks();
  const taskIndex = tasks.findIndex(t => t.id === id);
  
  if (taskIndex === -1) return null;
  
  // Update the task with the new fields
  const updatedTask = {
    ...tasks[taskIndex],
    ...updatedFields,
  };
  
  tasks[taskIndex] = updatedTask;
  localStorage.setItem('guestTasks', JSON.stringify(tasks));
  
  return updatedTask;
};

// Delete a task from localStorage
export const deleteGuestTask = (id: string): boolean => {
  const tasks = getGuestTasks();
  const filteredTasks = tasks.filter(t => t.id !== id);
  
  if (filteredTasks.length === tasks.length) return false;
  
  localStorage.setItem('guestTasks', JSON.stringify(filteredTasks));
  
  return true;
};import { Task } from "@shared/schema";

// Get all tasks from localStorage
export const getGuestTasks = (): Task[] => {
  const tasksJson = localStorage.getItem('guestTasks');
  if (!tasksJson) return [];
  
  try {
    return JSON.parse(tasksJson);
  } catch (error) {
    console.error('Error parsing guest tasks from localStorage', error);
    return [];
  }
};

// Save a new task to localStorage
export const saveGuestTask = (task: Omit<Task, 'id'> & { id?: string }): Task => {
  const tasks = getGuestTasks();
  
  // Generate a unique ID if one is not provided
  const newTask: Task = {
    ...task,
    id: task.id || crypto.randomUUID(),
  };
  
  tasks.push(newTask);
  localStorage.setItem('guestTasks', JSON.stringify(tasks));
  
  return newTask;
};

// Update a task in localStorage
export const updateGuestTask = (id: string, updatedFields: Partial<Task>): Task | null => {
  const tasks = getGuestTasks();
  const taskIndex = tasks.findIndex(t => t.id === id);
  
  if (taskIndex === -1) return null;
  
  // Update the task with the new fields
  const updatedTask = {
    ...tasks[taskIndex],
    ...updatedFields,
  };
  
  tasks[taskIndex] = updatedTask;
  localStorage.setItem('guestTasks', JSON.stringify(tasks));
  
  return updatedTask;
};

// Delete a task from localStorage
export const deleteGuestTask = (id: string): boolean => {
  const tasks = getGuestTasks();
  const filteredTasks = tasks.filter(t => t.id !== id);
  
  if (filteredTasks.length === tasks.length) return false;
  
  localStorage.setItem('guestTasks', JSON.stringify(filteredTasks));
  
  return true;
};
 [26/04/25, 5:52:57 PM] Anu: interface GuestHabit {
  id: string;
  name: string;
  frequency: string;
  startDate: string;
  completed: boolean;
  timeOfDay: string;
  streak: number;
  priority: string;
}

// Get all habits from localStorage
export const getGuestHabits = (): GuestHabit[] => {
  const habitsJson = localStorage.getItem('guestHabits');
  if (!habitsJson) return [];
  
  try {
    return JSON.parse(habitsJson);
  } catch (error) {
    console.error('Error parsing guest habits from localStorage', error);
    return [];
  }
};

// Save a new habit to localStorage
export const saveGuestHabit = (habit: Omit<GuestHabit, 'id'> & { id?: string }): GuestHabit => {
  const habits = getGuestHabits();
  
  // Generate a unique ID if one is not provided
  const newHabit: GuestHabit = {
    ...habit,
    id: habit.id || crypto.randomUUID(),
  };
  
  habits.push(newHabit);
  localStorage.setItem('guestHabits', JSON.stringify(habits));
  
  return newHabit;
};

// Update a habit in localStorage
export const updateGuestHabit = (id: string, updatedFields: Partial<GuestHabit>): GuestHabit | null => {
  const habits = getGuestHabits();
  const habitIndex = habits.findIndex(h => h.id === id);
  
  if (habitIndex === -1) return null;
  
  // Update the habit with the new fields
  const updatedHabit = {
    ...habits[habitIndex],
    ...updatedFields,
  };
  
  habits[habitIndex] = updatedHabit;
  localStorage.setItem('guestHabits', JSON.stringify(habits));
  
  return updatedHabit;
};

// Delete a habit from localStorage
export const deleteGuestHabit = (id: string): boolean => {
  const habits = getGuestHabits();
  const filteredHabits = habits.filter(h => h.id !== id);
  
  if (filteredHabits.length === habits.length) return false;
  
  localStorage.setItem('guestHabits', JSON.stringify(filteredHabits));
  
  return true;
};

// Toggle habit completion
export const toggleGuestHabitCompletion = (id: string): GuestHabit | null => {
  const habits = getGuestHabits();
  const habitIndex = habits.findIndex(h => h.id === id);
  
  if (habitIndex === -1) return null;
  
  // Toggle the completed status and update streak
  const habit = habits[habitIndex];
  const updatedHabit = {
    ...habit,
    completed: !habit.completed,
    streak: !habit.completed ? habit.streak + 1 : Math.max(0, habit.streak - 1)
  };
  
  habits[habitIndex] = updatedHabit;
  localStorage.setItem('guestHabits', JSON.stringify(habits));
  
  return updatedHabit;
};
 [26/04/25, 5:52:58 PM] Anu: import express, { Express, Request, Response, NextFunction } from "express";
import cors from "cors";
import dotenv from "dotenv";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";

dotenv.config();

(async () => {
  const app: Express = express();
  
  // Apply middleware
  app.use(cors());
  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));
  
  // Pass the Express app to register routes
  const server = await registerRoutes(app);
  
  // Global error handler
  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    log(Error: ${err.message});
    res.status(500).json({ message: err.message });
  });
  
  // Setup Vite integration for development
  if (process.env.NODE_ENV === "development") {
    await setupVite(app, server);
  } else {
    // Serve static files in production
    serveStatic(app);
  }
  
  // Start the server
  const PORT = process.env.PORT || 5000;
  server.listen(PORT, () => {
    log(Server is running on port ${PORT});
  });
})();
 [26/04/25, 5:52:59 PM] Anu: import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Express } from "express";
import session from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import { storage } from "./storage";
import { User as SelectUser } from "@shared/schema";

declare global {
  namespace Express {
    interface User extends SelectUser {}
  }
}

const scryptAsync = promisify(scrypt);

// Password hashing function
async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return ${buf.toString("hex")}.${salt};
}

// Password comparison function
async function comparePasswords(supplied: string, stored: string) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
  return timingSafeEqual(hashedBuf, suppliedBuf);
}

export function setupAuth(app: Express) {
  const sessionSettings: session.SessionOptions = {
    secret: process.env.SESSION_SECRET || "your-secret-key",
    resave: false,
    saveUninitialized: false,
    store: storage.sessionStore,
    cookie: {
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    },
  };

  app.set("trust proxy", 1);
  app.use(session(sessionSettings));
  app.use(passport.initialize());
  app.use(passport.session());

  // Configure local strategy for passport
  passport.use(
    new LocalStrategy(async (username, password, done) => {
      const user = await storage.getUserByUsername(username);
      if (!user || !(await comparePasswords(password, user.password))) {
        return done(null, false);
      } else {
        return done(null, user);
      }
    }),
  );

  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id: number, done) => {
    const user = await storage.getUser(id);
    done(null, user);
  });

  // Authentication routes
  app.post("/api/register", async (req, res, next) => {
    const existingUser = await storage.getUserByUsername(req.body.username);
    if (existingUser) {
      return res.status(400).send("Username already exists");
    }

    const user = await storage.createUser({
      ...req.body,
      password: await hashPassword(req.body.password),
    });

    req.login(user, (err) => {
      if (err) return next(err);
      res.status(201).json(user);
    });
  });

  app.post("/api/login", passport.authenticate("local"), (req, res) => {
    res.status(200).json(req.user);
  });

  app.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });

  app.get("/api/user", (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    res.json(req.user);
  });
}
 [26/04/25, 5:53:00 PM] Anu: import type { Express } from "express";
import { createServer, type Server } from "http";
import { setupAuth } from "./auth";
import { storage } from "./storage";

export async function registerRoutes(app: Express): Promise<Server> {
  // Set up authentication routes
  setupAuth(app);
  
  // Tasks endpoints
  app.get("/api/tasks", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    const tasks = await storage.getTasksByUserId(req.user.id);
    res.json(tasks);
  });
  
  app.post("/api/tasks", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    const task = await storage.createTask({
      ...req.body,
      userId: req.user.id,
    });
    
    res.status(201).json(task);
  });
  
  app.patch("/api/tasks/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    const task = await storage.getTask(req.params.id);
    
    if (!task) {
      return res.status(404).json({ message: "Task not found" });
    }
    
    if (task.userId !== req.user.id) {
      return res.status(403).json({ message: "Not authorized" });
    }
    
    const updatedTask = await storage.updateTask(req.params.id, req.body);
    res.json(updatedTask);
  });
  
  app.delete("/api/tasks/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    const task = await storage.getTask(req.params.id);
    
    if (!task) {
      return res.status(404).json({ message: "Task not found" });
    }
    
    if (task.userId !== req.user.id) {
      return res.status(403).json({ message: "Not authorized" });
    }
    
    await storage.deleteTask(req.params.id);
    res.status(204).end();
  });
  
  // Habits endpoints
  app.get("/api/habits", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    const habits = await storage.getHabitsByUserId(req.user.id);
    res.json(habits);
  });
  
  app.post("/api/habits", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    const habit = await storage.createHabit({
      ...req.body,
      userId: req.user.id,
    });
    
    res.status(201).json(habit);
  });
  
  // Add more endpoints for other features...
  
  const httpServer = createServer(app);
  return httpServer;
}
 [26/04/25, 5:53:01 PM] Anu: import { User, InsertUser, Task, InsertTask } from "@shared/schema";
import session from "express-session";
import crypto from "crypto";
import createMemoryStore from "memorystore";

const MemoryStore = createMemoryStore(session);

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  
  // Task methods
  getTask(id: string): Promise<Task | undefined>;
  getTasksByUserId(userId: number): Promise<Task[]>;
  createTask(task: InsertTask): Promise<Task>;
  updateTask(id: string, taskData: Partial<Task>): Promise<Task>;
  deleteTask(id: string): Promise<void>;
  
  // Habit methods
  getHabit(id: string): Promise<any | undefined>;
  getHabitsByUserId(userId: number): Promise<any[]>;
  createHabit(habit: any): Promise<any>;
  updateHabit(id: string, habitData: any): Promise<any>;
  deleteHabit(id: string): Promise<void>;
  
  // Session management
  sessionStore: session.SessionStore;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  private tasks: Map<string, Task>;
  private habits: Map<string, any>;
  private userId: number;
  sessionStore: session.SessionStore;
  
  constructor() {
    this.users = new Map();
    this.tasks = new Map();
    this.habits = new Map();
    this.userId = 1;
    this.sessionStore = new MemoryStore({
      checkPeriod: 86400000, // 24 hours
    });
  }
  
  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }
  
  async getUserByUsername(username: string): Promise<User | undefined> {
    for (const user of this.users.values()) {
      if (user.username === username) {
        return user;
      }
    }
    return undefined;
  }
  
  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.userId++;
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }
  
  async getTask(id: string): Promise<Task | undefined> {
    return this.tasks.get(id);
  }
  
  async getTasksByUserId(userId: number): Promise<Task[]> {
    const userTasks: Task[] = [];
    for (const task of this.tasks.values()) {
      if (task.userId === userId) {
        userTasks.push(task);
      }
    }
    return userTasks;
  }
  
  async createTask(insertTask: InsertTask): Promise<Task> {
    const id = crypto.randomUUID();
    const task: Task = { ...insertTask, id };
    this.tasks.set(id, task);
    return task;
  }
  
  async updateTask(id: string, taskData: Partial<Task>): Promise<Task> {
    const task = this.tasks.get(id);
    if (!task) {
      throw new Error("Task not found");
    }
    
    const updatedTask = { ...task, ...taskData };
    this.tasks.set(id, updatedTask);
    return updatedTask;
  }
  
  async deleteTask(id: string): Promise<void> {
    this.tasks.delete(id);
  }
  
  async getHabit(id: string): Promise<any | undefined> {
    return this.habits.get(id);
  }
  
  async getHabitsByUserId(userId: number): Promise<any[]> {
    const userHabits: any[] = [];
    for (const habit of this.habits.values()) {
      if (habit.userId === userId) {
        userHabits.push(habit);
      }
    }
    return userHabits;
  }
  
  async createHabit(habit: any): Promise<any> {
    const id = crypto.randomUUID();
    const newHabit = { ...habit, id };
    this.habits.set(id, newHabit);
    return newHabit;
  }
  
  async updateHabit(id: string, habitData: any): Promise<any> {
    const habit = this.habits.get(id);
    if (!habit) {
      throw new Error("Habit not found");
    }
    
    const updatedHabit = { ...habit, ...habitData };
    this.habits.set(id, updatedHabit);
    return updatedHabit;
  }
  
  async deleteHabit(id: string): Promise<void> {
    this.habits.delete(id);
  }
}

export const storage = new MemStorage();
 [26/04/25, 5:53:01 PM] Anu: import { pgTable, serial, text, integer, boolean, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Users table
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true, 
  password: true
});

// Tasks table
export const tasks = pgTable("tasks", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  date: text("date").notNull(),
  startTime: text("start_time").notNull(),
  endTime: text("end_time").notNull(),
  priority: text("priority").notNull().$type<"high" | "medium" | "low">(),
  completed: boolean("completed").default(false),
  userId: integer("user_id").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const insertTaskSchema = createInsertSchema(tasks)
  .omit({ id: true, createdAt: true });

// Habits table
export const habits = pgTable("habits", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  frequency: text("frequency").notNull(),
  startDate: text("start_date").notNull(),
  timeOfDay: text("time_of_day"),
  completed: boolean("completed").default(false),
  streak: integer("streak").default(0),
  priority: text("priority").$type<"high" | "medium" | "low">(),
  userId: integer("user_id").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const insertHabitSchema = createInsertSchema(habits)
  .omit({ id: true, createdAt: true });

// Type definitions
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type Task = typeof tasks.$inferSelect;
export type InsertTask = z.infer<typeof insertTaskSchema>;
export type Habit = typeof habits.$inferSelect;
export type InsertHabit = z.infer<typeof insertHabitSchema>;